# import os
# import shutil
# import zipfile
# import time
# import subprocess  # For managing LLM process
# import getpass  # For secure password input
# from cryptography.fernet import Fernet
# import user_management  # Importing the user management module
# import torch
# from transformers import AutoTokenizer, AutoModelForCausalLM

# # --- ENCRYPTION/DECRYPTION ---
# def generate_key():
#     key = Fernet.generate_key()
#     with open(os.path.join(os.getenv('HOME'), ".secret.key"), "wb") as key_file:
#         key_file.write(key)

# def load_key():
#     return open(os.path.join(os.getenv('HOME'), ".secret.key"), "rb").read()

# def encrypt_file(file_name):
#     key = load_key()
#     fernet = Fernet(key)
    
#     with open(file_name, "rb") as file:
#         file_data = file.read()
    
#     encrypted_data = fernet.encrypt(file_data)
    
#     with open(file_name, "wb") as file:
#         file.write(encrypted_data)
    
#     os.chmod(file_name, 0o600)
#     print(f"File '{file_name}' has been encrypted and secured.")

# def decrypt_file(file_name):
#     key = load_key()
#     fernet = Fernet(key)
    
#     with open(file_name, "rb") as file:
#         encrypted_data = file.read()
    
#     decrypted_data = fernet.decrypt(encrypted_data)
    
#     with open(file_name, "wb") as file:
#         file.write(decrypted_data)
    
#     print(f"File '{file_name}' has been decrypted and is accessible.")

# # --- LLM PROCESS HANDLING ---
# def start_llm():
#     print("\nStarting the locally running LLM...")
#     llm_process = subprocess.Popen(['start_llm'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
#     time.sleep(2)
#     return llm_process

# def stop_llm(llm_process):
#     print("\nStopping the locally running LLM...")
#     llm_process.terminate()
#     print("LLM has been stopped.")

# def generate_code_with_llm(prompt):
#     llm_process = start_llm()
#     print(f"\nSending request to LLM: '{prompt}'...")
#     code_response = "def generated_code():\n    print('This is generated by the LLM')"
#     print(f"Code generated by the LLM:\n{code_response}")
#     stop_llm(llm_process)
#     return code_response

# # --- HUGGING FACE MISTRAL INFERENCE ---
# # Load the Mistral model and tokenizer
# def load_mistral_model():
#     model_name = "mistral/mistral"  # Specify the correct model name
#     tokenizer = AutoTokenizer.from_pretrained(model_name)
#     model = AutoModelForCausalLM.from_pretrained(model_name)

#     # Set the model to evaluation mode and use the CPU or GPU
#     model.eval()
#     device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
#     model.to(device)

#     return tokenizer, model

# def generate_text_mistral(prompt, max_length=100):
#     tokenizer, model = load_mistral_model()
    
#     # Tokenize the input prompt
#     inputs = tokenizer(prompt, return_tensors="pt").to(model.device)
    
#     # Generate text using the model
#     with torch.no_grad():
#         outputs = model.generate(**inputs, max_length=max_length, num_return_sequences=1)
    
#     # Decode the generated tokens to text
#     generated_text = tokenizer.decode(outputs[0], skip_special_tokens=True)
#     return generated_text

# # --- ADVANCED CLI-BASED TEXT EDITOR ---
# def cli_code_editor(file_name):
#     print("\nEntering CLI-Based Code Editor.")
#     print("Commands:")
#     print(":w -> Save")
#     print(":q -> Quit without saving")
#     print(":wq -> Save and Quit")
#     print(":undo -> Undo last line")
#     print(":ask_llm -> Ask the LLM for code assistance")
#     print(":ask_mistral -> Ask Mistral for text generation")

#     if os.path.exists(file_name):
#         with open(file_name, "r") as file:
#             lines = file.readlines()
#         print(f"Editing existing file '{file_name}'")
#     else:
#         lines = []
#         print(f"Creating new file '{file_name}'")

#     while True:
#         command = input("\n> ")
        
#         if command == ":wq":
#             with open(file_name, "w") as file:
#                 file.writelines(lines)
#             print(f"File '{file_name}' saved.")
#             break
        
#         elif command == ":w":
#             with open(file_name, "w") as file:
#                 file.writelines(lines)
#             print(f"File '{file_name}' saved.")
        
#         elif command == ":q":
#             print("Exiting without saving.")
#             break
        
#         elif command == ":undo":
#             if lines:
#                 undone_line = lines.pop(-1)
#                 print(f"Undone last line: {undone_line.strip()}")
#             else:
#                 print("No lines to undo.")
        
#         elif command.startswith(":ask_llm"):
#             prompt = input("Describe what you need help with or the code you want to generate: ")
#             llm_generated_code = generate_code_with_llm(prompt)
#             lines.append(llm_generated_code + "\n")
        
#         elif command.startswith(":ask_mistral"):
#             prompt = input("Enter your prompt for Mistral: ")
#             mistral_generated_text = generate_text_mistral(prompt)
#             lines.append(mistral_generated_text + "\n")
#             print("Generated Text:\n", mistral_generated_text)
        
#         else:
#             lines.append(command + "\n")

#     return file_name

# # --- FILE SELECTION FOR EDITING ---
# def select_file_for_editing():
#     print("Available files in the current directory:")
#     for f in os.listdir('.'):
#         if os.path.isfile(f):
#             print(f" - {f}")

#     file_name = input("Enter the name of the file you want to edit: ")
    
#     if os.path.exists(file_name):
#         cli_code_editor(file_name)
#     else:
#         print("File does not exist. Please try again.")

# # --- Create New File and Write Generated Code from LLM Using CLI-Based Editor ---
# def create_file_with_generated_code():
#     file_name = input("Enter file name: ")
#     if os.path.exists(file_name):
#         print(f"File '{file_name}' already exists. Opening for editing...")
#         select_file_for_editing()
#     else:
#         file_name = cli_code_editor(file_name)
#         encrypt_file(file_name)
#         print(f"Code has been written and encrypted in '{file_name}'.")

# # --- FILE MANAGEMENT FUNCTIONS ---
# def print_current_directory():
#     print("Current Directory Structure:")
#     for root, dirs, files in os.walk(".", topdown=True):
#         level = root.replace(os.path.sep, "").count(os.path.sep)
#         sub_indent = " " * 4 * (level + 1)
#         for f in files:
#             print(f"{sub_indent}{f}")

# def delete_file_or_folder():
#     path = input("Enter file/folder name to delete: ")
#     if os.path.isdir(path):
#         shutil.rmtree(path)
#         print(f"Folder '{path}' deleted.")
#     elif os.path.isfile(path):
#         os.remove(path)
#         print(f"File '{path}' deleted.")
#     else:
#         print(f"'{path}' does not exist.")
#     print_current_directory()

# # --- BACKUP AND RESTORE FUNCTIONS ---
# def backup_file(file_name):
#     backup_name = f"{file_name}.bak"
#     shutil.copy(file_name, backup_name)
#     print(f"Backup created: {backup_name}")

# def restore_file(backup_name):
#     if os.path.exists(backup_name):
#         original_name = backup_name[:-4]  # Remove '.bak'
#         shutil.copy(backup_name, original_name)
#         print(f"Restored '{original_name}' from '{backup_name}'")
#     else:
#         print(f"Backup file '{backup_name}' does not exist.")

# # --- COMPRESS AND DECOMPRESS FUNCTIONS ---
# def compress_file(file_name):
#     with zipfile.ZipFile(f"{file_name}.zip", 'w') as zipf:
#         zipf.write(file_name)
#     print(f"Compressed '{file_name}' into '{file_name}.zip'")

# def decompress_file(zip_name):
#     with zipfile.ZipFile(zip_name, 'r') as zipf:
#         zipf.extractall(os.path.splitext(zip_name)[0])  # Extract to a folder named after the zip file
#     print(f"Decompressed '{zip_name}'")

# # --- MAIN FUNCTION ---
# def main():
#     print("Welcome to the Unix-based Secure File Management System")

#     # Only one user allowed
#     while True:
#         choice = input("Do you want to (1) Register or (2) Login? ")
#         if choice == '1':
#             password = getpass.getpass("Enter password: ")
#             user_management.register_user(password)  # Register user
#             break  # Exit after registration
#         elif choice == '2':
#             password = getpass.getpass("Enter password: ")
#             if user_management.verify_user(password):  # Verify user
#                 break  # Exit after successful login

#     while True:
#         print("\nOptions:")
#         print("1. Create New File with LLM Assistance")
#         print("2. Select Existing File to Edit")
#         print("3. Delete File/Folder")
#         print("4. Search Files")
#         print("5. Display File Metadata")
#         print("6. Backup File")
#         print("7. Restore File from Backup")
#         print("8. Compress File")
#         print("9. Decompress File")
#         print("10. Exit")

#         option = input("Enter your option: ")
        
#         if option == '1':
#             create_file_with_generated_code()
#         elif option == '2':
#             select_file_for_editing()  # Added option for editing existing files
#         elif option == '3':
#             delete_file_or_folder()
#         elif option == '4':
#             ext = input("Enter file extension to search (or press Enter to search by name): ")
#             name = input("Enter file name to search (or press Enter to skip): ")
#             # Implement search_files function here if needed
#         elif option == '5':
#             file_name = input("Enter file name for metadata: ")
#             # Implement display_file_metadata function here if needed
#         elif option == '6':
#             file_name = input("Enter file name to backup: ")
#             backup_file(file_name)
#         elif option == '7':
#             backup_name = input("Enter backup file name to restore: ")
#             restore_file(backup_name)
#         elif option == '8':
#             file_name = input("Enter file name to compress: ")
#             compress_file(file_name)
#         elif option == '9':
#             zip_name = input("Enter ZIP file name to decompress: ")
#             decompress_file(zip_name)
#         elif option == '10':
#             print("Goodbye!")
#             break
#         else:
#             print("Invalid option. Please try again.")

# if __name__ == "__main__":
#     generate_key()  # Generate encryption key at the start
#     main()  # Start the program



import os
import shutil
import zipfile
import time
import subprocess  # For managing LLM process
import getpass  # For secure password input
from cryptography.fernet import Fernet
import user_management  # Importing the user management module
import torch
from transformers import AutoTokenizer, AutoModelForCausalLM
import datetime  # For file metadata

# --- ENCRYPTION/DECRYPTION ---
def generate_key():
    key = Fernet.generate_key()
    with open(os.path.join(os.getenv('HOME'), ".secret.key"), "wb") as key_file:
        key_file.write(key)

def load_key():
    return open(os.path.join(os.getenv('HOME'), ".secret.key"), "rb").read()

def encrypt_file(file_name):
    key = load_key()
    fernet = Fernet(key)
    
    with open(file_name, "rb") as file:
        file_data = file.read()
    
    encrypted_data = fernet.encrypt(file_data)
    
    with open(file_name, "wb") as file:
        file.write(encrypted_data)
    
    os.chmod(file_name, 0o600)
    print(f"File '{file_name}' has been encrypted and secured.")

def decrypt_file(file_name):
    key = load_key()
    fernet = Fernet(key)
    
    with open(file_name, "rb") as file:
        encrypted_data = file.read()
    
    decrypted_data = fernet.decrypt(encrypted_data)
    
    with open(file_name, "wb") as file:
        file.write(decrypted_data)
    
    print(f"File '{file_name}' has been decrypted and is accessible.")

# --- LLM PROCESS HANDLING ---
def start_llm():
    print("\nStarting the locally running LLM...")
    llm_process = subprocess.Popen(['start_llm'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    time.sleep(2)
    return llm_process

def stop_llm(llm_process):
    print("\nStopping the locally running LLM...")
    llm_process.terminate()
    print("LLM has been stopped.")

def generate_code_with_llm(prompt):
    llm_process = start_llm()
    print(f"\nSending request to LLM: '{prompt}'...")
    code_response = "def generated_code():\n    print('This is generated by the LLM')"
    print(f"Code generated by the LLM:\n{code_response}")
    stop_llm(llm_process)
    return code_response

# --- HUGGING FACE MISTRAL INFERENCE ---
# Load the Mistral model and tokenizer
def load_mistral_model():
    model_name = "mistral/mistral"  # Specify the correct model name
    tokenizer = AutoTokenizer.from_pretrained(model_name)
    model = AutoModelForCausalLM.from_pretrained(model_name)

    # Set the model to evaluation mode and use the CPU or GPU
    model.eval()
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)

    return tokenizer, model

def generate_text_mistral(prompt, max_length=100):
    tokenizer, model = load_mistral_model()
    
    # Tokenize the input prompt
    inputs = tokenizer(prompt, return_tensors="pt").to(model.device)
    
    # Generate text using the model
    with torch.no_grad():
        outputs = model.generate(**inputs, max_length=max_length, num_return_sequences=1)
    
    # Decode the generated tokens to text
    generated_text = tokenizer.decode(outputs[0], skip_special_tokens=True)
    return generated_text

# --- ADVANCED CLI-BASED TEXT EDITOR ---
def cli_code_editor(file_name):
    print("\nEntering CLI-Based Code Editor.")
    print("Commands:")
    print(":w -> Save")
    print(":q -> Quit without saving")
    print(":wq -> Save and Quit")
    print(":undo -> Undo last line")
    print(":ask_llm -> Ask the LLM for code assistance")
    print(":ask_mistral -> Ask Mistral for text generation")

    if os.path.exists(file_name):
        with open(file_name, "r") as file:
            lines = file.readlines()
        print(f"Editing existing file '{file_name}'")
    else:
        lines = []
        print(f"Creating new file '{file_name}'")

    while True:
        command = input("\n> ")
        
        if command == ":wq":
            with open(file_name, "w") as file:
                file.writelines(lines)
            print(f"File '{file_name}' saved.")
            break
        
        elif command == ":w":
            with open(file_name, "w") as file:
                file.writelines(lines)
            print(f"File '{file_name}' saved.")
        
        elif command == ":q":
            print("Exiting without saving.")
            break
        
        elif command == ":undo":
            if lines:
                undone_line = lines.pop(-1)
                print(f"Undone last line: {undone_line.strip()}")
            else:
                print("No lines to undo.")
        
        elif command.startswith(":ask_llm"):
            prompt = input("Describe what you need help with or the code you want to generate: ")
            llm_generated_code = generate_code_with_llm(prompt)
            lines.append(llm_generated_code + "\n")
        
        elif command.startswith(":ask_mistral"):
            prompt = input("Enter your prompt for Mistral: ")
            mistral_generated_text = generate_text_mistral(prompt)
            lines.append(mistral_generated_text + "\n")
            print("Generated Text:\n", mistral_generated_text)
        
        else:
            lines.append(command + "\n")

    return file_name

# --- FILE SEARCH FUNCTION ---
def search_files(extension=None, name=None):
    print(f"Searching for files with extension '{extension}' or name '{name}' in the current directory...")
    found_files = []
    for root, dirs, files in os.walk("."):
        for file in files:
            if extension and file.endswith(extension):
                found_files.append(os.path.join(root, file))
            elif name and name in file:
                found_files.append(os.path.join(root, file))

    if found_files:
        print("Found Files:")
        for f in found_files:
            print(f" - {f}")
    else:
        print("No files found matching the criteria.")

# --- FILE METADATA FUNCTION ---
def display_file_metadata(file_name):
    if os.path.exists(file_name):
        stats = os.stat(file_name)
        size = stats.st_size
        creation_time = time.ctime(stats.st_ctime)
        last_modified_time = time.ctime(stats.st_mtime)

        print(f"Metadata for '{file_name}':")
        print(f" - Size: {size} bytes")
        print(f" - Created: {creation_time}")
        print(f" - Last Modified: {last_modified_time}")
    else:
        print(f"File '{file_name}' does not exist.")

# --- FILE SELECTION FOR EDITING ---
def select_file_for_editing():
    print("Available files in the current directory:")
    for f in os.listdir('.'):
        if os.path.isfile(f):
            print(f" - {f}")

    file_name = input("Enter the name of the file you want to edit: ")
    
    if os.path.exists(file_name):
        cli_code_editor(file_name)
    else:
        print("File does not exist. Please try again.")

# --- Create New File and Write Generated Code from LLM Using CLI-Based Editor ---
def create_file_with_generated_code():
    file_name = input("Enter file name: ")
    if os.path.exists(file_name):
        print(f"File '{file_name}' already exists. Opening for editing...")
        select_file_for_editing()
    else:
        file_name = cli_code_editor(file_name)
        encrypt_file(file_name)
        print(f"Code has been written and encrypted in '{file_name}'.")

# --- FILE MANAGEMENT FUNCTIONS ---
def print_current_directory():
    print("Current Directory Structure:")
    for root, dirs, files in os.walk(".", topdown=True):
        level = root.replace(os.path.sep, "").count(os.path.sep)
        sub_indent = " " * 4 * (level + 1)
        for f in files:
            print(f"{sub_indent}{f}")

def delete_file_or_folder():
    path = input("Enter file/folder name to delete: ")
    if os.path.isdir(path):
        shutil.rmtree(path)
        print(f"Folder '{path}' deleted.")
    elif os.path.isfile(path):
        os.remove(path)
        print(f"File '{path}' deleted.")
    else:
        print(f"'{path}' does not exist.")
    print_current_directory()

# --- BACKUP AND RESTORE FUNCTIONS ---
def backup_file(file_name):
    backup_name = f"{file_name}.bak"
    shutil.copy(file_name, backup_name)
    print(f"Backup created: {backup_name}")

def restore_file(backup_name):
    if os.path.exists(backup_name):
        original_name = backup_name[:-4]  # Remove '.bak'
        shutil.copy(backup_name, original_name)
        print(f"Restored '{original_name}' from '{backup_name}'")
    else:
        print(f"Backup file '{backup_name}' does not exist.")

# --- COMPRESS AND DECOMPRESS FUNCTIONS ---
def compress_file(file_name):
    with zipfile.ZipFile(f"{file_name}.zip", 'w') as zipf:
        zipf.write(file_name)
    print(f"Compressed '{file_name}' into '{file_name}.zip'")

def decompress_file(zip_name):
    with zipfile.ZipFile(zip_name, 'r') as zipf:
        zipf.extractall(os.path.splitext(zip_name)[0])  # Extract to a folder named after the zip file
    print(f"Decompressed '{zip_name}'")

# --- MAIN FUNCTION ---
def main():
    print("Welcome to the Unix-based Secure File Management System")

    # Multi-user login and registration
    while True:
        choice = input("Do you want to (1) Register or (2) Login? ")
        if choice == '1':
            username = input("Enter username: ")
            password = getpass.getpass("Enter password: ")
            user_management.register_user(username, password)  # Register user
            break  # Exit after registration
        elif choice == '2':
            username = input("Enter username: ")
            password = getpass.getpass("Enter password: ")
            if user_management.verify_user(username, password):  # Verify user
                break  # Exit after successful login

    while True:
        print("\nOptions:")
        print("1. Create New File with LLM Assistance")
        print("2. Select Existing File to Edit")
        print("3. Delete File/Folder")
        print("4. Search Files")
        print("5. Display File Metadata")
        print("6. Backup File")
        print("7. Restore File from Backup")
        print("8. Compress File")
        print("9. Decompress File")
        print("10. Exit")

        option = input("Enter your option: ")
        
        if option == '1':
            create_file_with_generated_code()
        elif option == '2':
            select_file_for_editing()  # Added option for editing existing files
        elif option == '3':
            delete_file_or_folder()
        elif option == '4':
            ext = input("Enter file extension to search (or press Enter to search by name): ")
            name = input("Enter file name to search (or press Enter to skip): ")
            search_files(extension=ext, name=name)
        elif option == '5':
            file_name = input("Enter file name for metadata: ")
            display_file_metadata(file_name)
        elif option == '6':
            file_name = input("Enter file name to backup: ")
            backup_file(file_name)
        elif option == '7':
            backup_name = input("Enter backup file name to restore: ")
            restore_file(backup_name)
        elif option == '8':
            file_name = input("Enter file name to compress: ")
            compress_file(file_name)
        elif option == '9':
            zip_name = input("Enter ZIP file name to decompress: ")
            decompress_file(zip_name)
        elif option == '10':
            print("Goodbye!")
            break
        else:
            print("Invalid option. Please try again.")

if __name__ == "__main__":
    generate_key()  # Generate encryption key at the start
    main()  # Start the program
